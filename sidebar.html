<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <style>
      /* Basic styling */
      body { font-family: sans-serif; margin: 10px; }
      #results { margin-top: 15px; border-top: 1px solid #ccc; padding-top: 10px; }
      .comment-block { border: 1px solid #eee; padding: 8px; margin-bottom: 8px; transition: border-color 0.3s ease; }
      .comment-quote { font-style: italic; color: #555; margin-bottom: 4px; }
      .comment-text { }
      button { margin-top: 5px; }
      textarea { width: 95%; margin-top: 2px; height: 80px; font-family: inherit; }
      .focused-comment { border-color: #4285F4; border-width: 2px; }
      label { display: block; margin-top: 10px; font-weight: bold;}
    </style>
  </head>
  <body>
    <h1>Document Analysis</h1>

    <div>
      <label for="apiKey">Gemini API Key:</label>
      <input type="password" id="apiKey" style="width: 95%;">
      <small>Need a key? <a href="https://ai.google.dev/gemini-api/docs/api-key" target="_blank">Get one here</a>.</small>
    </div>

    <div>
        <label for="customPrompt">Analysis Prompt:</label>
        <textarea id="customPrompt"></textarea>
    </div>

    <button id="analyzeButton">Analyze for Comments</button>

    <div id="results">
      <!-- Comments will be displayed here -->
      <p>Enter your API key and click the button to analyze.</p>
    </div>

    <script>
      const HIGHLIGHT_COLOR = '#FFF8C4'; // Define on client-side too
      const DOC_TEXT_PLACEHOLDER = '{docText}';
      const defaultPrompt = `Please review the following document text and provide constructive comments. For each comment, identify the exact phrase or sentence from the text that the comment refers to. Present your output STRICTLY as a JSON array of objects, where each object has a "quote" key (containing the exact text phrase) and a "comment" key (containing your feedback). Do not include any text outside of the JSON array.\n\nExample format:\n[\n  {\n    "quote": "This is a sentence to comment on.",\n    "comment": "This sentence could be clearer."
  },\n  {\n    "quote": "Another phrase needing feedback.",\n    "comment": "Consider rephrasing this part."
  }\n]\n\nDocument Text:\n---\n${DOC_TEXT_PLACEHOLDER}\n---`;

      document.getElementById('customPrompt').value = defaultPrompt;
      document.getElementById('analyzeButton').addEventListener('click', analyzeDocument);

      let currentComments = []; // Store the current comments with quotes
      let currentlyFocusedCommentId = null;
      let pollingInterval = null;

      function analyzeDocument() {
        const apiKey = document.getElementById('apiKey').value;
        const customPromptTemplate = document.getElementById('customPrompt').value;
        const resultsDiv = document.getElementById('results');
        const analyzeButton = document.getElementById('analyzeButton');

        if (!apiKey) {
          resultsDiv.innerHTML = '<p style="color: red;">Please enter your Gemini API Key. <a href="https://ai.google.dev/gemini-api/docs/api-key" target="_blank">Need help?</a></p>';
          return;
        }
        if (!customPromptTemplate) {
          resultsDiv.innerHTML = '<p style="color: red;">Please enter a prompt.</p>';
          return;
        }

        // Disable button and show loading state
        analyzeButton.disabled = true;
        resultsDiv.innerHTML = '<p>Fetching document content...</p>';
        stopPolling(); // Stop polling while fetching new comments

        google.script.run
          .withSuccessHandler(handleDocContent)
          .withFailureHandler(handleError)
          .getDocumentContent();
      }

      function handleDocContent(docContent) {
        console.log("Document Content Received (first 100 chars):", docContent.substring(0, 100));
        const apiKey = document.getElementById('apiKey').value;
        const customPromptTemplate = document.getElementById('customPrompt').value;
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = '<p>Analyzing content with Gemini...</p>';

        if (!docContent || docContent.trim().length === 0) {
            resultsDiv.innerHTML = '<p>Document is empty, nothing to analyze.</p>';
            document.getElementById('analyzeButton').disabled = false; // Re-enable button
            return;
        }

        // Replace placeholder in prompt with actual document content
        const finalPrompt = customPromptTemplate.replace(DOC_TEXT_PLACEHOLDER, docContent);

        google.script.run
          .withSuccessHandler(displayComments)
          .withFailureHandler(handleError)
          .getGeminiComments(finalPrompt, apiKey); // Pass final prompt
      }

      function displayComments(comments) {
         const resultsDiv = document.getElementById('results');
         const analyzeButton = document.getElementById('analyzeButton');
         analyzeButton.disabled = false;

         console.log("Comments received:", comments);
         currentComments = comments; // Store comments for later use
         currentlyFocusedCommentId = null; // Reset focus
         clearFocus(); // Clear visual focus

         if (!comments || comments.length === 0) {
           resultsDiv.innerHTML = '<p>No comments were generated.</p>';
           stopPolling();
           return;
         }

         // Render comments
         let html = '<h2>Generated Comments:</h2>';
         comments.forEach((comment, index) => {
           const commentId = `comment-${index}`;
           // Use commentId for the div id
           html += `<div class="comment-block" data-quote="${escapeHtml(comment.quote)}" id="${commentId}">`;
           html += `<div class="comment-quote">${escapeHtml(comment.quote)}</div>`;
           html += `<div class="comment-text">${escapeHtml(comment.comment)}</div>`;
           html += '</div>';
         });
         resultsDiv.innerHTML = html;

         // After rendering, extract quotes and request highlighting
         const quotesToHighlight = comments.map(c => c.quote);
         console.log("Requesting document highlighting for quotes:", quotesToHighlight);
         google.script.run
            .withSuccessHandler(onHighlightSuccess)
            .withFailureHandler(onHighlightError)
            .highlightCommentsInDoc(quotesToHighlight); // Pass only quotes
      }

      function onHighlightSuccess() {
        console.log("Document highlighting successful.");
        // Start polling for cursor focus
        startPolling();
      }

      function onHighlightError(error) {
        console.error("Highlighting Error:", error);
        // Maybe show a non-fatal error to the user
        // document.getElementById('results').innerHTML += '<p style="color: orange;">Could not highlight comments in document.</p>';
        // Still start polling even if highlighting fails?
        startPolling();
      }

      function handleError(error) {
        const resultsDiv = document.getElementById('results');
        const analyzeButton = document.getElementById('analyzeButton');
        analyzeButton.disabled = false; // Re-enable button
        stopPolling(); // Stop polling on error

        // Log the full error for debugging
        console.error("Script Error:", JSON.stringify(error, null, 2));

        // Display a user-friendly message
        resultsDiv.innerHTML = `<p style="color: red;">Error: ${escapeHtml(error.message || String(error))}</p>`;

        // Special handling for API key errors
        if (typeof error.message === 'string' && (error.message.includes('API key not valid') || error.message.includes('API_KEY_INVALID'))) {
            resultsDiv.innerHTML += `<p style="color: red;">Please check your Gemini API Key. <a href="https://ai.google.dev/gemini-api/docs/api-key" target="_blank">Need help?</a></p>`;
        }
      }

      // --- Cursor Focus Polling --- 

      function startPolling() {
        if (pollingInterval) return;
        console.log("Starting focus polling interval.");
        pollingInterval = setInterval(() => {
          console.log("Polling: Calling getCursorState..."); // Updated function name
          google.script.run
            .withSuccessHandler(updateFocus)
            .withFailureHandler(logPollingError)
            .getCursorState(); // Updated function name
        }, 1500);
      }

      function stopPolling() {
        if (pollingInterval) {
          console.log("Stopping focus polling.");
          clearInterval(pollingInterval);
          pollingInterval = null;
          clearFocus(); // Clear focus when stopping polling
        }
      }

      function updateFocus(cursorState) {
        console.log("Polling: Received from getCursorState:", cursorState);

        let foundCommentId = null;

        if (cursorState && cursorState.bgColor === HIGHLIGHT_COLOR && cursorState.elementText && currentComments.length > 0) {
            // Cursor is in a highlighted area with text content, try to find the specific comment
            const elementText = cursorState.elementText;
            const cursorOffset = cursorState.offset;

            console.log(`Polling: Cursor in highlight. Offset: ${cursorOffset}, Element Text (start): ${elementText.substring(0, 50)}...`);

            for (let i = 0; i < currentComments.length; i++) {
                const comment = currentComments[i];
                const quote = comment.quote;
                let startIndex = -1;
                let searchFrom = 0;

                // Find all occurrences of the quote within the element text
                while ((startIndex = elementText.indexOf(quote, searchFrom)) !== -1) {
                    const endIndex = startIndex + quote.length;
                    console.log(`Polling: Checking quote "${quote}" found at index ${startIndex} (ends ${endIndex})`);
                    
                    // Check if the cursor offset is within this quote occurrence
                    // The cursor offset is 0-based. It's considered "within" if it's >= start and <= end.
                    // If offset is 0, it's at the very beginning. If offset is length, it's after the last char.
                    if (cursorOffset >= startIndex && cursorOffset <= endIndex) {
                        console.log(`Polling: Cursor offset ${cursorOffset} is within quote bounds [${startIndex}, ${endIndex}]. Match found!`);
                        foundCommentId = `comment-${i}`;
                        break; // Found the comment for this cursor position
                    }
                    
                    // Prepare for the next search iteration to find subsequent occurrences
                    searchFrom = startIndex + 1; 
                }

                if (foundCommentId) {
                    break; // Exit the outer loop once a match is found
                }
            }
            if (!foundCommentId) {
                 console.log("Polling: Cursor in highlight, but couldn't match offset to a known quote within the element text.");
            }

        } else {
            // Cursor is not in a highlighted area, or missing data
            console.log("Polling: Cursor not in highlighted area or missing data.");
        }

        // Update focus based on whether a comment was found
        if (foundCommentId) {
            if (currentlyFocusedCommentId !== foundCommentId) {
                console.log(`Polling: Setting focus to ${foundCommentId}`);
                setFocus(foundCommentId);
            }
        } else {
            if (currentlyFocusedCommentId !== null) {
                console.log("Polling: Clearing focus.");
                clearFocus();
            }
        }
      }

      function setFocus(commentId) {
        clearFocus(); // Clear previous focus first
        const newElement = document.getElementById(commentId);
        if (newElement) {
            console.log("Focusing comment:", commentId);
            newElement.classList.add('focused-comment');
            // Optional: Scroll into view
            newElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            currentlyFocusedCommentId = commentId;
        } else {
            console.warn("setFocus: Could not find comment block with id:", commentId);
            currentlyFocusedCommentId = null;
        }
      }

      function clearFocus() {
         if (currentlyFocusedCommentId) {
             console.log("Clearing focus from:", currentlyFocusedCommentId);
             const oldElement = document.getElementById(currentlyFocusedCommentId);
             if (oldElement) {
                oldElement.classList.remove('focused-comment');
             }
             currentlyFocusedCommentId = null;
         }
      }

      function logPollingError(error) {
          console.warn("Polling Error (likely transient):", error);
      }

      // --- Utility Functions --- 

      // Utility function to prevent basic XSS
      function escapeHtml(unsafe) {
          if (typeof unsafe !== 'string') {
              console.warn('escapeHtml called with non-string:', unsafe);
              return unsafe; // Return as-is if not a string
          }
          return unsafe
               .replace(/&/g, "&amp;")
               .replace(/</g, "&lt;")
               .replace(/>/g, "&gt;")
               .replace(/"/g, "&quot;")
               .replace(/'/g, "&#039;");
      }

      // Utility function to escape quotes for CSS selectors
      function escapeCssSelector(str) {
        if (!str) return '';
        return str.replace(/(["'\\!#$%&()*+,./:;<=>?@[\]^`{|}~])/g, '\\$1');
      }

    </script>
  </body>
</html> 