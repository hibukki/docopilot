<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <!-- Add Material Icons and Roboto font (optional but nice for Material feel) -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
      :root {
        --primary-color: #1a73e8; /* Google Blue */
        --focus-border-color: #4285F4;
        --background-color: #f8f9fa;
        --surface-color: #ffffff;
        --on-surface-color: #202124;
        --on-surface-variant-color: #5f6368;
        --border-color: #dadce0;
        --hover-background: #f1f3f4;
        --highlight-color: #FFF8C4; 
        --focused-highlight-color: #FFD54F;
        --border-radius: 8px;
        --spacing-unit: 8px;
      }

      /* Basic styling */
      body {
        font-family: 'Roboto', sans-serif;
        margin: 0;
        padding: calc(var(--spacing-unit) * 2);
        background-color: var(--background-color);
        color: var(--on-surface-color);
        font-size: 14px;
      }

      h1 {
        font-size: 18px;
        font-weight: 500;
        margin: 0 0 var(--spacing-unit) 0;
        color: var(--on-surface-variant-color);
      }

      #results { 
        margin-top: calc(var(--spacing-unit) * 2);
        border-top: 1px solid var(--border-color);
        padding-top: calc(var(--spacing-unit) * 2);
      }
      
      .comment-block {
        background-color: var(--surface-color);
        border: 1px solid var(--border-color);
        padding: var(--spacing-unit) calc(var(--spacing-unit) * 1.5);
        margin-bottom: var(--spacing-unit);
        border-radius: var(--border-radius);
        cursor: pointer;
        transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
      }
      
      .comment-block:hover {
        background-color: var(--hover-background);
      }
      
      /* Remove quote display */
      /* .comment-quote { font-style: italic; color: var(--on-surface-variant-color); margin-bottom: calc(var(--spacing-unit) / 2); font-size: 13px; } */
      
      .comment-text {
         line-height: 1.5;
      }
      
      button {
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 4px;
        padding: calc(var(--spacing-unit) * 1) calc(var(--spacing-unit) * 2);
        margin-top: calc(var(--spacing-unit) * 2);
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s ease-in-out;
      }
      
      button:hover {
          background-color: #1558b0; /* Darker blue */
      }
      
      button:disabled {
          background-color: #bdbdbd;
          cursor: not-allowed;
      }

      textarea {
        width: calc(100% - 16px); /* Account for padding */
        margin-top: calc(var(--spacing-unit) / 2);
        height: 100px;
        font-family: inherit;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: calc(var(--spacing-unit));
        font-size: 13px;
      }
      
      input[type="password"] {
        width: calc(100% - 16px); /* Account for padding */
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: var(--spacing-unit);
        margin-top: calc(var(--spacing-unit) / 2);
      }
      
      .focused-comment {
        border-color: var(--focus-border-color);
        border-width: 2px;
        padding: calc(var(--spacing-unit) - 1px) calc(var(--spacing-unit) * 1.5 - 1px); /* Adjust padding for border */
      }
      
      label {
        display: block;
        margin-top: calc(var(--spacing-unit) * 1.5);
        font-weight: 500;
        font-size: 13px;
        color: var(--on-surface-variant-color);
      }

      details {
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        margin-bottom: calc(var(--spacing-unit) * 2);
        background-color: var(--surface-color);
      }
      
      summary {
        font-weight: 500;
        padding: var(--spacing-unit) calc(var(--spacing-unit) * 1.5);
        cursor: pointer;
        list-style: none; /* Remove default arrow */
        position: relative;
        color: var(--on-surface-variant-color);
      }

      summary::-webkit-details-marker {
        display: none; /* Hide default arrow for Chrome/Safari */
      }

      summary::before {
        /* Custom arrow */
        content: '\e5c8'; /* Material icon name: keyboard_arrow_down */
        font-family: 'Material Icons';
        position: absolute;
        right: calc(var(--spacing-unit) * 1.5);
        top: 50%;
        transform: translateY(-50%) rotate(0deg);
        transition: transform 0.2s ease-in-out;
        font-size: 20px;
      }

      details[open] summary::before {
        transform: translateY(-50%) rotate(180deg);
      }
      
      .settings-content {
          padding: 0 calc(var(--spacing-unit) * 1.5) calc(var(--spacing-unit) * 1.5);
          border-top: 1px solid var(--border-color);
      }

      small {
        font-size: 12px;
        color: var(--on-surface-variant-color);
        display: block;
        margin-top: calc(var(--spacing-unit) / 2);
      }
    </style>
  </head>
  <body>
    <h1>Docopilot</h1>

    <details>
      <summary>Settings</summary>
      <div class="settings-content">
        <div>
          <label for="apiKey">Gemini API Key:</label>
          <input type="password" id="apiKey" style="width: calc(100% - 16px);">
          <small>Need a key? <a href="https://ai.google.dev/gemini-api/docs/api-key" target="_blank">Get one here</a>.</small>
        </div>
    
        <div>
            <label for="customPrompt">Analysis Prompt:</label>
            <textarea id="customPrompt"></textarea>
        </div>
      </div>
    </details>

    <button id="analyzeButton">Analyze for Comments</button>

    <div id="results">
      <!-- Comments will be displayed here -->
      <p>Enter your API key and click the button to analyze.</p>
    </div>

    <script>
      const HIGHLIGHT_COLOR = '#FFF8C4'; // Define on client-side too
      const FOCUSED_HIGHLIGHT_COLOR = '#FFD54F'; // Define on client-side too
      const DOC_TEXT_PLACEHOLDER = '{docText}';
      const defaultPrompt = `Please review the following document text and provide 2-5 constructive comments. For each comment, identify the exact phrase or sentence from the text that the comment refers to. Present your output STRICTLY as a JSON array of objects, where each object has a "quote" key (containing the exact text phrase) and a "comment" key (containing your feedback). Do not include any text outside of the JSON array.\n\nExample format:\n[\n  {\n    "quote": "This is a sentence to comment on.",\n    "comment": "This sentence could be clearer."
  },\n  {\n    "quote": "Another phrase needing feedback.",\n    "comment": "Consider rephrasing this part."
  }\n]\n\nDocument Text:\n---\n${DOC_TEXT_PLACEHOLDER}\n---`;

      document.getElementById('customPrompt').value = defaultPrompt;
      document.getElementById('analyzeButton').addEventListener('click', analyzeDocument);

      // Load saved API key on startup
      google.script.run
        .withSuccessHandler(populateApiKey)
        .withFailureHandler(logInitialApiKeyError)
        .getApiKey();

      let currentComments = []; // Store the current comments with quotes
      let currentlyFocusedCommentId = null;
      let pollingInterval = null;

      // Start polling immediately after sidebar setup
      startPolling();

      function populateApiKey(savedKey) {
        if (savedKey) {
          console.log("Found saved API key, populating input.");
          document.getElementById('apiKey').value = savedKey;
        } else {
          console.log("No saved API key found.");
        }
      }

      function logInitialApiKeyError(error) {
        console.error("Error getting saved API key on load:", error);
        // Optional: Display a message to the user if needed
      }

      function analyzeDocument() {
        const apiKey = document.getElementById('apiKey').value;
        const customPromptTemplate = document.getElementById('customPrompt').value;
        const resultsDiv = document.getElementById('results');
        const analyzeButton = document.getElementById('analyzeButton');

        if (!apiKey) {
          resultsDiv.innerHTML = '<p style="color: red;">Please enter your Gemini API Key. <a href="https://ai.google.dev/gemini-api/docs/api-key" target="_blank">Need help?</a></p>';
          return;
        }
        if (!customPromptTemplate) {
          resultsDiv.innerHTML = '<p style="color: red;">Please enter a prompt.</p>';
          return;
        }

        // Disable button and show loading state
        analyzeButton.disabled = true;
        resultsDiv.innerHTML = '<p>Fetching document content...</p>';

        // Save the key when analysis is attempted (if valid)
        if (apiKey) {
           console.log("Attempting to save API Key..."); // Add log for saving
           google.script.run.saveApiKey(apiKey);
        }

        google.script.run
          .withSuccessHandler(handleDocContent)
          .withFailureHandler(handleError)
          .getDocumentContent();
      }

      function handleDocContent(docContent) {
        console.log("Document Content Received (first 100 chars):", docContent.substring(0, 100));
        const apiKey = document.getElementById('apiKey').value;
        const customPromptTemplate = document.getElementById('customPrompt').value;
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = '<p>Analyzing content with Gemini...</p>';

        if (!docContent || docContent.trim().length === 0) {
            resultsDiv.innerHTML = '<p>Document is empty, nothing to analyze.</p>';
            document.getElementById('analyzeButton').disabled = false; // Re-enable button
            return;
        }

        // Replace placeholder in prompt with actual document content
        const finalPrompt = customPromptTemplate.replace(DOC_TEXT_PLACEHOLDER, docContent);

        google.script.run
          .withSuccessHandler(displayComments)
          .withFailureHandler(handleError)
          .getGeminiComments(finalPrompt, apiKey); // Pass final prompt
      }

      function displayComments(comments) {
         const resultsDiv = document.getElementById('results');
         const analyzeButton = document.getElementById('analyzeButton');
         analyzeButton.disabled = false;

         console.log("Comments received:", comments);
         currentComments = comments; // Store comments for later use
         currentlyFocusedCommentId = null; // Reset focus
         clearSidebarFocus(); // Clear visual focus

         if (!comments || comments.length === 0) {
           resultsDiv.innerHTML = '<p>No comments were generated.</p>';
           return;
         }

         // Render comments
         let html = '<h2>Comments:</h2>'; // Changed title
         comments.forEach((comment, index) => {
           const commentId = `comment-${index}`;
           html += `<div class="comment-block" data-quote="${escapeHtml(comment.quote)}" id="${commentId}">`;
           html += `<div class="comment-text">${escapeHtml(comment.comment)}</div>`;
           html += '</div>';
         });
         resultsDiv.innerHTML = html;

         // Add click listeners AFTER rendering
         comments.forEach((_, index) => {
           const commentId = `comment-${index}`;
           const element = document.getElementById(commentId);
           if (element) {
             element.addEventListener('click', () => setCommentFocus(commentId));
           }
         });

         // Initial highlighting (no focus)
         setCommentFocus(null);
      }

      function onHighlightSuccess() {
        console.log("onHighlightSuccess: Document highlighting successful.");
      }

      function onHighlightError(error) {
        console.error("Highlighting Error:", error);
        // Maybe show a non-fatal error to the user
        // document.getElementById('results').innerHTML += '<p style="color: orange;">Could not highlight comments in document.</p>';
        // Still start polling even if highlighting fails?
      }

      function handleError(error) {
        const resultsDiv = document.getElementById('results');
        const analyzeButton = document.getElementById('analyzeButton');
        analyzeButton.disabled = false; // Re-enable button

        // Log the full error for debugging
        console.error("Script Error:", JSON.stringify(error, null, 2));

        // Display a user-friendly message
        resultsDiv.innerHTML = `<p style="color: red;">Error: ${escapeHtml(error.message || String(error))}</p>`;

        // Special handling for API key errors
        if (typeof error.message === 'string' && (error.message.includes('API key not valid') || error.message.includes('API_KEY_INVALID'))) {
            resultsDiv.innerHTML += `<p style="color: red;">Please check your Gemini API Key. <a href="https://ai.google.dev/gemini-api/docs/api-key" target="_blank">Need help?</a></p>`;
        }
      }

      // --- Cursor Focus Polling --- 

      function startPolling() {
        if (pollingInterval) {
            console.log("startPolling: Polling already active.");
            return; 
        }
        console.log("startPolling: Setting up polling interval...");
        pollingInterval = setInterval(() => {
          console.log("Polling Interval: Calling getCursorState...");
          google.script.run
            .withSuccessHandler(updateFocus)
            .withFailureHandler(logPollingError)
            .getCursorState();
        }, 1500);
      }

      function updateFocus(cursorState) {
        console.log("Polling Interval: Received state:", cursorState);

        let foundCommentId = null;

        if (cursorState && cursorState.elementText && currentComments.length > 0) {
            const elementText = cursorState.elementText;
            const cursorOffset = cursorState.offset;

            for (let i = 0; i < currentComments.length; i++) {
                const comment = currentComments[i];
                const quote = comment.quote;
                let startIndex = -1;
                let searchFrom = 0;

                while ((startIndex = elementText.indexOf(quote, searchFrom)) !== -1) {
                    const endIndex = startIndex + quote.length;
                    
                    if (cursorOffset >= startIndex && cursorOffset <= endIndex) {
                        console.log(`Polling: Cursor offset ${cursorOffset} is within quote bounds [${startIndex}, ${endIndex}]. Match found for comment-${i}!`);
                        foundCommentId = `comment-${i}`;
                        break;
                    }
                    searchFrom = startIndex + 1; 
                }
                if (foundCommentId) {
                    break;
                }
            }
            if (!foundCommentId) {
                 console.log("Polling: Cursor position doesn't match any known quote bounds within the current text element.");
            }
        } else {
            console.log("Polling: No cursor state, element text, or comments available for matching.");
        }

        // Update focus based on whether a comment was found
        if (currentlyFocusedCommentId !== foundCommentId) {
             setCommentFocus(foundCommentId); // Call the central focus function
        }
      }

      /**
       * Central function to set the focus on a specific comment (or clear focus).
       * Handles both sidebar UI and document highlighting.
       * @param {string | null} commentId The ID of the comment to focus, or null to clear focus.
       */
      function setCommentFocus(commentId) {
        console.log(`Setting focus. Target comment ID: ${commentId}`);
        const previouslyFocusedId = currentlyFocusedCommentId;

        // 1. Update Sidebar UI Focus
        clearSidebarFocus(); // Clear previous sidebar visual focus
        let quoteToFocus = null;
        if (commentId) {
            const newElement = document.getElementById(commentId);
            if (newElement) {
                console.log("Focusing sidebar element:", commentId);
                newElement.classList.add('focused-comment');
                newElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                currentlyFocusedCommentId = commentId;
                // Retrieve the quote text associated with this comment ID for highlighting
                quoteToFocus = newElement.getAttribute('data-quote');
            } else {
                console.warn("setCommentFocus: Could not find comment block with id:", commentId);
                currentlyFocusedCommentId = null;
            }
        }

        // 2. Update Document Highlighting 
        if (currentlyFocusedCommentId !== previouslyFocusedId || !commentId) {
             console.log(`Requesting document highlight update. Focused quote: "${quoteToFocus || 'None'}"`);
            const allQuotes = currentComments.map(c => c.quote);
            google.script.run
                .withSuccessHandler(onHighlightSuccess)
                .withFailureHandler(onHighlightError)
                .highlightCommentsInDoc(allQuotes, quoteToFocus);
        }
      }

      // Renamed from clearFocus for clarity
      function clearSidebarFocus() {
         if (currentlyFocusedCommentId) {
             console.log("Clearing sidebar focus from:", currentlyFocusedCommentId);
             const oldElement = document.getElementById(currentlyFocusedCommentId);
             if (oldElement) {
                oldElement.classList.remove('focused-comment');
             }
             currentlyFocusedCommentId = null;
         }
      }

      function logPollingError(error) {
          console.warn("Polling Error (likely transient):", error);
      }

      // --- Utility Functions --- 

      // Utility function to prevent basic XSS
      function escapeHtml(unsafe) {
          if (typeof unsafe !== 'string') {
              console.warn('escapeHtml called with non-string:', unsafe);
              return unsafe; // Return as-is if not a string
          }
          return unsafe
               .replace(/&/g, "&amp;")
               .replace(/</g, "&lt;")
               .replace(/>/g, "&gt;")
               .replace(/"/g, "&quot;")
               .replace(/'/g, "&#039;");
      }

      // Utility function to escape quotes for CSS selectors
      function escapeCssSelector(str) {
        if (!str) return '';
        return str.replace(/(["'\!#$%&()*+,./:;<=>?@[\]^`{|}~])/g, '\$1');
      }

    </script>
  </body>
</html>