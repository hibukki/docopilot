<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <!-- Add Material Icons and Roboto font (optional but nice for Material feel) -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
      :root {
        --primary-color: #1a73e8; /* Google Blue */
        --focus-border-color: #4285F4;
        --background-color: #f8f9fa;
        --surface-color: #ffffff;
        --on-surface-color: #202124;
        --on-surface-variant-color: #5f6368;
        --border-color: #dadce0;
        --hover-background: #f1f3f4;
        --highlight-color: #FFF8C4; 
        --focused-highlight-color: #FFD54F;
        --border-radius: 8px;
        --spacing-unit: 8px;
      }

      /* Basic styling */
      body {
        font-family: 'Roboto', sans-serif;
        margin: 0;
        padding: calc(var(--spacing-unit) * 2);
        background-color: var(--background-color);
        color: var(--on-surface-color);
        font-size: 14px;
      }

      h1 {
        font-size: 18px;
        font-weight: 500;
        margin: 0 0 var(--spacing-unit) 0;
        color: var(--on-surface-variant-color);
      }

      #results { 
        margin-top: calc(var(--spacing-unit) * 2);
        border-top: 1px solid var(--border-color);
        padding-top: calc(var(--spacing-unit) * 2);
      }
      
      .comment-block {
        background-color: var(--surface-color);
        border: 1px solid var(--border-color);
        padding: var(--spacing-unit) calc(var(--spacing-unit) * 1.5);
        margin-bottom: var(--spacing-unit);
        border-radius: var(--border-radius);
        cursor: pointer;
        transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
      }
      
      .comment-block:hover {
        background-color: var(--hover-background);
      }
      
      /* Remove quote display */
      /* .comment-quote { font-style: italic; color: var(--on-surface-variant-color); margin-bottom: calc(var(--spacing-unit) / 2); font-size: 13px; } */
      
      .comment-text {
         line-height: 1.5;
      }
      
      button {
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 4px;
        padding: calc(var(--spacing-unit) * 1) calc(var(--spacing-unit) * 2);
        margin-top: calc(var(--spacing-unit) * 2);
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s ease-in-out;
      }
      
      button:hover {
          background-color: #1558b0; /* Darker blue */
      }
      
      button:disabled {
          background-color: #bdbdbd;
          cursor: not-allowed;
      }

      textarea {
        width: calc(100% - 16px); /* Account for padding */
        margin-top: calc(var(--spacing-unit) / 2);
        height: 100px;
        font-family: inherit;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: calc(var(--spacing-unit));
        font-size: 13px;
      }
      
      input[type="password"] {
        width: calc(100% - 16px); /* Account for padding */
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: var(--spacing-unit);
        margin-top: calc(var(--spacing-unit) / 2);
      }
      
      .focused-comment {
        border-color: var(--focus-border-color);
        border-width: 2px;
        padding: calc(var(--spacing-unit) - 1px) calc(var(--spacing-unit) * 1.5 - 1px); /* Adjust padding for border */
      }
      
      label {
        display: block;
        margin-top: calc(var(--spacing-unit) * 1.5);
        font-weight: 500;
        font-size: 13px;
        color: var(--on-surface-variant-color);
      }

      details {
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        margin-bottom: calc(var(--spacing-unit) * 2);
        background-color: var(--surface-color);
      }
      
      summary {
        font-weight: 500;
        padding: var(--spacing-unit) calc(var(--spacing-unit) * 1.5);
        cursor: pointer;
        list-style: none; /* Remove default arrow */
        position: relative;
        color: var(--on-surface-variant-color);
      }

      summary::-webkit-details-marker {
        display: none; /* Hide default arrow for Chrome/Safari */
      }

      summary::before {
        /* Custom arrow */
        content: '\e5c8'; /* Material icon name: keyboard_arrow_down */
        font-family: 'Material Icons';
        position: absolute;
        right: calc(var(--spacing-unit) * 1.5);
        top: 50%;
        transform: translateY(-50%) rotate(0deg);
        transition: transform 0.2s ease-in-out;
        font-size: 20px;
      }

      details[open] summary::before {
        transform: translateY(-50%) rotate(180deg);
      }
      
      .settings-content {
          padding: 0 calc(var(--spacing-unit) * 1.5) calc(var(--spacing-unit) * 1.5);
          border-top: 1px solid var(--border-color);
      }

      small {
        font-size: 12px;
        color: var(--on-surface-variant-color);
        display: block;
        margin-top: calc(var(--spacing-unit) / 2);
      }
    </style>
  </head>
  <body>
    <h1>Docopilot</h1>

    <details>
      <summary>Settings</summary>
      <div class="settings-content">
        <!-- API Key Section -->
        <div>
          <label for="apiKey">Gemini API Key:</label>
          <input type="password" id="apiKey" style="width: calc(100% - 16px);">
          <small>Need a key? <a href="https://ai.google.dev/gemini-api/docs/api-key" target="_blank">Get one here</a>.</small>
        </div>
    
        <!-- Prompt Section -->
        <div>
            <label for="customPrompt">
                Analysis Prompt:
                <button id="resetPromptButton" title="Reset to default prompt" style="float: right; background: none; border: none; color: var(--primary-color); cursor: pointer; padding: 0; font-size: 12px; margin-top: -2px;">(Reset)</button>
                <button id="savePromptButton" title="Save current prompt" style="float: right; background: none; border: none; color: var(--primary-color); cursor: pointer; padding: 0; font-size: 12px; margin-top: -2px; margin-right: 5px; display: none;">(Save)</button>
            </label>
            <textarea id="customPrompt"></textarea>
        </div>
      </div>
    </details>

    <button id="analyzeButton">Analyze for Comments</button>

    <div id="results">
      <!-- Comments will be displayed here -->
      <p>Enter your API key and click the button to analyze.</p>
    </div>

    <script>
      const HIGHLIGHT_COLOR = '#FFF8C4';
      const FOCUSED_HIGHLIGHT_COLOR = '#FFD54F';
      const DOC_TEXT_PLACEHOLDER = '{docText}';

      // Initialization
      document.getElementById('analyzeButton').addEventListener('click', analyzeDocument);
      document.getElementById('resetPromptButton').addEventListener('click', resetPromptToDefault);
      document.getElementById('savePromptButton').addEventListener('click', saveCurrentPrompt);
      document.getElementById('customPrompt').addEventListener('input', handlePromptInputChange);

      // Load initial state from server
      google.script.run
        .withSuccessHandler(populateApiKey)
        .withFailureHandler(logInitialApiKeyError)
        .getApiKey();
      google.script.run
        .withSuccessHandler(populatePrompt)
        .withFailureHandler(logPromptError) // Add error handler for prompt
        .getUserOrDefaultPrompt(); 

      let currentComments = [];
      let currentlyFocusedCommentId = null;
      let pollingInterval = null;
      let lastProcessedCursorState = null;
      let loadedPromptValue = ''; 
      let lastDocContent = null;        // Store last known document content
      let lastChangeTimestamp = 0;    // Timestamp of last detected content change
      let analysisDebounceTimer = null; // Timer for debouncing auto-analysis
      const AUTO_ANALYSIS_DELAY = 1500; // Wait 1.5 seconds after last change

      startPolling();

      // --- Helper Functions --- 
      function getApiKeyInputValue() {
        return document.getElementById('apiKey').value;
      }

      function getPromptInputValue() {
        return document.getElementById('customPrompt').value;
      }

      // --- Initial Population --- 
      function populateApiKey(savedKey) {
        if (savedKey) {
          console.log("Found saved API key, populating input.");
          document.getElementById('apiKey').value = savedKey;
        } else {
          console.log("No saved API key found.");
        }
      }

      function populatePrompt(promptText) {
        console.log("Populating prompt text area.");
        const textarea = document.getElementById('customPrompt');
        textarea.value = promptText;
        loadedPromptValue = promptText; // Store the loaded value
        handlePromptInputChange(); // Check initial state for save button visibility
      }

      function logInitialApiKeyError(error) {
        console.error("Error getting saved API key on load:", error);
        // Optional: Display a message to the user if needed
      }

      function logPromptError(error) {
          console.error("Error getting user/default prompt on load:", error);
          // Maybe display a fallback or default directly in the textarea
      }

      // --- Button Actions / Event Handlers --- 
      function analyzeDocument() {
        const apiKey = getApiKeyInputValue();
        const customPromptTemplate = getPromptInputValue();
        const resultsDiv = document.getElementById('results');
        const analyzeButton = document.getElementById('analyzeButton');

        if (!apiKey) {
          resultsDiv.innerHTML = '<p style="color: red;">Please enter your Gemini API Key. <a href="https://ai.google.dev/gemini-api/docs/api-key" target="_blank">Need help?</a></p>';
          return;
        }
        if (!customPromptTemplate) {
          resultsDiv.innerHTML = '<p style="color: red;">Please enter a prompt.</p>';
          return;
        }

        // Disable button and show loading state
        analyzeButton.disabled = true;
        resultsDiv.innerHTML = '<p>Fetching document content...</p>';

        // Save the key (prompt is saved via explicit button)
        if (apiKey) {
           console.log("Attempting to save API Key...");
           google.script.run.saveApiKey(apiKey);
        }
       
        google.script.run
          .withSuccessHandler(handleDocContent)
          .withFailureHandler(handleError)
          .getDocumentContent();
      }

      function resetPromptToDefault() {
          console.log("Resetting prompt to default...");
          google.script.run
              .withSuccessHandler(promptText => { 
                  populatePrompt(promptText); // Update textarea and loaded value
                  // Explicitly clear saved user prompt property when resetting
                  google.script.run.saveUserPrompt(null);
              })
              .withFailureHandler(logPromptError)
              .getDefaultPrompt();
      }

      function saveCurrentPrompt() {
          const currentPrompt = document.getElementById('customPrompt').value;
          console.log("Saving current prompt...");
          google.script.run
              .withSuccessHandler(() => {
                  console.log("Save successful handler: Updating loaded value and hiding button.");
                  loadedPromptValue = currentPrompt; // Update the baseline
                  handlePromptInputChange(); // Hide button again
              })
              .withFailureHandler(logPromptError) // Can reuse prompt error logger
              .saveUserPrompt(currentPrompt);
      }

      function handlePromptInputChange() {
          const currentPrompt = document.getElementById('customPrompt').value;
          const saveButton = document.getElementById('savePromptButton');
          if (currentPrompt !== loadedPromptValue) {
              saveButton.style.display = 'inline'; // Show save button
          } else {
              saveButton.style.display = 'none'; // Hide save button
          }
      }

      function handleDocContent(docContent) {
        console.log("Document Content Received (first 100 chars):", docContent.substring(0, 100));
        const apiKey = getApiKeyInputValue();
        const customPromptTemplate = getPromptInputValue();
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = '<p>Analyzing content with Gemini...</p>';

        if (!docContent || docContent.trim().length === 0) {
            resultsDiv.innerHTML = '<p>Document is empty, nothing to analyze.</p>';
            document.getElementById('analyzeButton').disabled = false; // Re-enable button
            return;
        }

        // Replace placeholder in prompt with actual document content
        const finalPrompt = customPromptTemplate.replace(DOC_TEXT_PLACEHOLDER, docContent);

        google.script.run
          .withSuccessHandler(displayComments)
          .withFailureHandler(handleError)
          .getGeminiComments(finalPrompt, apiKey); // Pass final prompt
      }

      function displayComments(comments) {
         const resultsDiv = document.getElementById('results');
         const analyzeButton = document.getElementById('analyzeButton');
         analyzeButton.disabled = false;

         console.log("Comments received:", comments);
         currentComments = comments; // Store comments for later use
         currentlyFocusedCommentId = null; // Reset focus
         clearSidebarFocus(); // Clear visual focus

         if (!comments || comments.length === 0) {
           resultsDiv.innerHTML = '<p>No comments were generated.</p>';
           return;
         }

         // Render comments
         let html = '<h2>Comments:</h2>'; // Changed title
         comments.forEach((comment, index) => {
           const commentId = `comment-${index}`;
           html += `<div class="comment-block" data-quote="${escapeHtml(comment.quote)}" id="${commentId}">`;
           html += `<div class="comment-text">${escapeHtml(comment.comment)}</div>`;
           html += '</div>';
         });
         resultsDiv.innerHTML = html;

         // Add click listeners AFTER rendering
         comments.forEach((_, index) => {
           const commentId = `comment-${index}`;
           const element = document.getElementById(commentId);
           if (element) {
             // Call setCommentFocus AND trigger scroll on click
             element.addEventListener('click', () => {
                setCommentFocus(commentId);
                const quoteToScroll = element.getAttribute('data-quote');
                if (quoteToScroll) {
                  console.log("Click detected, requesting scroll to:", quoteToScroll);
                  google.script.run
                    .withFailureHandler(logScrollError) // Add a simple error handler
                    .scrollToQuote(quoteToScroll);
                }
             });
           }
         });

         // Initial highlighting (no focus or scroll)
         setCommentFocus(null);
      }

      function onHighlightSuccess() {
        console.log("onHighlightSuccess: Document highlighting successful.");
      }

      function onHighlightError(error) {
        console.error("Highlighting Error:", error);
        // Maybe show a non-fatal error to the user
        // document.getElementById('results').innerHTML += '<p style="color: orange;">Could not highlight comments in document.</p>';
        // Still start polling even if highlighting fails?
      }

      function handleError(error) {
        const resultsDiv = document.getElementById('results');
        const analyzeButton = document.getElementById('analyzeButton');
        analyzeButton.disabled = false; // Re-enable button

        // Log the full error for debugging
        console.error("Script Error:", JSON.stringify(error, null, 2));

        // Display a user-friendly message
        resultsDiv.innerHTML = `<p style="color: red;">Error: ${escapeHtml(error.message || String(error))}</p>`;

        // Special handling for API key errors
        if (typeof error.message === 'string' && (error.message.includes('API key not valid') || error.message.includes('API_KEY_INVALID'))) {
            resultsDiv.innerHTML += `<p style="color: red;">Please check your Gemini API Key. <a href="https://ai.google.dev/gemini-api/docs/api-key" target="_blank">Need help?</a></p>`;
        }
      }

      // --- Cursor Focus Polling & Auto-Analysis --- 

      function startPolling() {
        if (pollingInterval) {
            console.log("startPolling: Polling already active.");
            return; 
        }
        console.log("startPolling: Setting up polling interval...");
        pollingInterval = setInterval(() => {
          console.log("Polling Interval: Calling getCursorState and getDocumentContent...");
          // Fetch both pieces of state concurrently
          Promise.all([
            new Promise((resolve, reject) => google.script.run.withSuccessHandler(resolve).withFailureHandler(reject).getCursorState()),
            new Promise((resolve, reject) => google.script.run.withSuccessHandler(resolve).withFailureHandler(reject).getDocumentContent())
          ]).then(([cursorState, docContent]) => {
            handlePollingResults(cursorState, docContent);
          }).catch(error => {
            logPollingError(error); // Log error if either call fails
          });
        }, 1500); // Keep polling interval (adjust if needed)
      }

      function handlePollingResults(cursorState, docContent) {
          // 1. Handle Cursor Focus Update (as before)
          handleCursorFocus(cursorState);

          // 2. Handle Auto-Analysis based on Document Content Change
          handleAutoAnalysis(docContent);
      }

      // Renamed from updateFocus to be more specific
      function handleCursorFocus(cursorState) { 
        console.log("handleCursorFocus: Processing state:", cursorState);

        // Optimization: Check if cursor context actually changed
        if (lastProcessedCursorState && cursorState && 
            lastProcessedCursorState.elementText === cursorState.elementText && 
            lastProcessedCursorState.offset === cursorState.offset) {
            console.log("handleCursorFocus: Cursor state unchanged. Skipping update.");
            lastProcessedCursorState = cursorState; 
            return;
        }
        lastProcessedCursorState = cursorState; 

        let foundCommentId = null;

        if (cursorState && cursorState.elementText && currentComments.length > 0) {
            const elementText = cursorState.elementText;
            const cursorOffset = cursorState.offset;

            for (let i = 0; i < currentComments.length; i++) {
                const comment = currentComments[i];
                const quote = comment.quote;
                let startIndex = -1;
                let searchFrom = 0;

                while ((startIndex = elementText.indexOf(quote, searchFrom)) !== -1) {
                    const endIndex = startIndex + quote.length;
                    
                    if (cursorOffset >= startIndex && cursorOffset <= endIndex) {
                        console.log(`handleCursorFocus: Cursor offset ${cursorOffset} is within quote bounds [${startIndex}, ${endIndex}]. Match found for comment-${i}!`);
                        foundCommentId = `comment-${i}`;
                        break;
                    }
                    searchFrom = startIndex + 1; 
                }
                if (foundCommentId) {
                    break;
                }
            }
            if (!foundCommentId) {
                 console.log("handleCursorFocus: Cursor position doesn't match any known quote bounds within the current text element.");
            }
        } else {
            console.log("handleCursorFocus: No cursor state, element text, or comments available for matching.");
        }

        // Update focus UI
        if (currentlyFocusedCommentId !== foundCommentId) {
             console.log(`handleCursorFocus: Focus target changed to ${foundCommentId}. Calling setCommentFocus.`);
             setCommentFocus(foundCommentId);
        } else {
             console.log(`handleCursorFocus: Focus target (${foundCommentId}) remains the same.`);
        }
      }

      function handleAutoAnalysis(docContent) {
        console.log("handleAutoAnalysis: Checking content...");
        if (docContent === null || docContent === undefined) {
            console.log("handleAutoAnalysis: Received null/undefined content. Skipping.");
            return;
        }

        if (docContent !== lastDocContent) {
            console.log("handleAutoAnalysis: Document content changed.");
            lastDocContent = docContent;
            lastChangeTimestamp = Date.now();
            // Clear existing debounce timer if content changes again
            if (analysisDebounceTimer) {
                console.log("handleAutoAnalysis: Clearing existing analysis timer.");
                clearTimeout(analysisDebounceTimer);
                analysisDebounceTimer = null;
            }
             // Set a new timer to trigger analysis after delay
            console.log(`handleAutoAnalysis: Setting analysis timer for ${AUTO_ANALYSIS_DELAY}ms.`);
            analysisDebounceTimer = setTimeout(() => {
                console.log("handleAutoAnalysis: Debounce delay elapsed. Triggering analysis.");
                analysisDebounceTimer = null; // Clear the timer variable
                // Check API key etc. before triggering
                const apiKey = getApiKeyInputValue();
                const customPromptTemplate = getPromptInputValue();
                if (apiKey && customPromptTemplate) {
                    getCommentsFromLLM(); // Call the trigger function
                } else {
                    console.log("handleAutoAnalysis: Skipping auto-analysis due to missing API key or prompt.");
                }
            }, AUTO_ANALYSIS_DELAY);

        } else {
            console.log("handleAutoAnalysis: Document content unchanged.");
            // Optional: Could add logic here to check if the delay has passed *without* a timer already set,
            // but the current logic with resetting the timer on change is simpler.
        }
      }

      function getCommentsFromLLM() {
          console.log("getCommentsFromLLM: Starting analysis..."); // Renamed log
          const apiKey = getApiKeyInputValue(); // Use helper
          const customPromptTemplate = getPromptInputValue(); // Use helper
          const resultsDiv = document.getElementById('results');
          // resultsDiv.innerHTML = '<p>Auto-analyzing...</p>'; 

          google.script.run
            .withSuccessHandler(handleDocContent)
            .withFailureHandler(handleError)
            .getDocumentContent();
      }

      /**
       * Central function to set the focus on a specific comment (or clear focus).
       * Handles both sidebar UI and document highlighting.
       * @param {string | null} commentId The ID of the comment to focus, or null to clear focus.
       */
      function setCommentFocus(commentId) {
        console.log(`setCommentFocus: Target comment ID: ${commentId}`);
        const previouslyFocusedId = currentlyFocusedCommentId;

        const quoteToFocus = updateSidebarFocusUI(commentId);

        // Update Document Highlighting ONLY if focus actually changed
        if (currentlyFocusedCommentId !== previouslyFocusedId) {
            updateDocumentHighlighting(quoteToFocus);
        }
      }
      
      /**
       * Updates the sidebar UI to show the focused comment.
       * @param {string | null} commentId The ID of the comment to focus, or null.
       * @returns {string | null} The quote text associated with the focused comment, or null.
       */
      function updateSidebarFocusUI(commentId) {
        clearSidebarFocus(); // Clear previous sidebar visual focus
        let quoteToFocus = null;
        if (commentId) {
            const newElement = document.getElementById(commentId);
            if (newElement) {
                console.log("Focusing sidebar element:", commentId);
                newElement.classList.add('focused-comment');
                newElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                currentlyFocusedCommentId = commentId;
                quoteToFocus = newElement.getAttribute('data-quote');
            } else {
                console.warn("updateSidebarFocusUI: Could not find comment block with id:", commentId);
                currentlyFocusedCommentId = null;
            }
        }
        return quoteToFocus;
      }

      /**
       * Calls the server to update the document highlighting based on the focused quote.
       * @param {string | null} quoteToFocus The quote to highlight with focus color, or null.
       */
      function updateDocumentHighlighting(quoteToFocus) {
          console.log(`Requesting document highlight update. Focused quote: "${quoteToFocus || 'None'}"`);
          const allQuotes = currentComments.map(c => c.quote);
          google.script.run
              .withFailureHandler(onHighlightError) // Highlight error handler
              .highlightCommentsInDoc(allQuotes, quoteToFocus); // Just highlight
      }

      // Renamed from clearFocus for clarity -> Now clearSidebarFocus
      function clearSidebarFocus() {
         if (currentlyFocusedCommentId) {
             console.log("Clearing sidebar focus from:", currentlyFocusedCommentId);
             const oldElement = document.getElementById(currentlyFocusedCommentId);
             if (oldElement) {
                oldElement.classList.remove('focused-comment');
             }
             currentlyFocusedCommentId = null;
         }
      }

      function logPollingError(error) {
          console.warn("Polling Error (likely transient):", error);
      }

      function logScrollError(error) {
          console.error("Error during scrollToQuote call:", error);
      }

      // --- Utility Functions --- 

      // Utility function to prevent basic XSS
      function escapeHtml(unsafe) {
          if (typeof unsafe !== 'string') {
              console.warn('escapeHtml called with non-string:', unsafe);
              return unsafe; // Return as-is if not a string
          }
          return unsafe
               .replace(/&/g, "&amp;")
               .replace(/</g, "&lt;")
               .replace(/>/g, "&gt;")
               .replace(/"/g, "&quot;")
               .replace(/'/g, "&#039;");
      }

      // Utility function to escape quotes for CSS selectors
      function escapeCssSelector(str) {
        if (!str) return '';
        return str.replace(/(["'\!#$%&()*+,./:;<=>?@[\]^`{|}~])/g, '\$1');
      }

    </script>
  </body>
</html>