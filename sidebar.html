<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <style>
      /* Basic styling */
      body { font-family: sans-serif; margin: 10px; }
      #results { margin-top: 15px; border-top: 1px solid #ccc; padding-top: 10px; }
      .comment-block { border: 1px solid #eee; padding: 8px; margin-bottom: 8px; transition: border-color 0.3s ease; }
      .comment-quote { font-style: italic; color: #555; margin-bottom: 4px; }
      .comment-text { }
      button { margin-top: 5px; }
      textarea { width: 95%; margin-top: 2px; height: 80px; font-family: inherit; }
      .focused-comment { border-color: #4285F4; border-width: 2px; }
      label { display: block; margin-top: 10px; font-weight: bold;}
    </style>
  </head>
  <body>
    <h1>Document Analysis</h1>

    <div>
      <label for="apiKey">Gemini API Key:</label>
      <input type="password" id="apiKey" style="width: 95%;">
      <small>Need a key? <a href="https://ai.google.dev/gemini-api/docs/api-key" target="_blank">Get one here</a>.</small>
    </div>

    <div>
        <label for="customPrompt">Analysis Prompt:</label>
        <textarea id="customPrompt"></textarea>
    </div>

    <button id="analyzeButton">Analyze for Comments</button>

    <div id="results">
      <!-- Comments will be displayed here -->
      <p>Enter your API key and click the button to analyze.</p>
    </div>

    <script>
      const HIGHLIGHT_COLOR = '#FFF8C4'; // Define on client-side too
      const FOCUSED_HIGHLIGHT_COLOR = '#FFD54F'; // Define on client-side too
      const DOC_TEXT_PLACEHOLDER = '{docText}';
      const defaultPrompt = `Please review the following document text and provide 2-5 constructive comments. For each comment, identify the exact phrase or sentence from the text that the comment refers to. Present your output STRICTLY as a JSON array of objects, where each object has a "quote" key (containing the exact text phrase) and a "comment" key (containing your feedback). Do not include any text outside of the JSON array.\n\nExample format:\n[\n  {\n    "quote": "This is a sentence to comment on.",\n    "comment": "This sentence could be clearer."
  },\n  {\n    "quote": "Another phrase needing feedback.",\n    "comment": "Consider rephrasing this part."
  }\n]\n\nDocument Text:\n---\n${DOC_TEXT_PLACEHOLDER}\n---`;

      document.getElementById('customPrompt').value = defaultPrompt;
      document.getElementById('analyzeButton').addEventListener('click', analyzeDocument);

      // Load saved API key on startup
      google.script.run.withSuccessHandler(populateApiKey).getApiKey();

      let currentComments = []; // Store the current comments with quotes
      let currentlyFocusedCommentId = null;
      let pollingInterval = null;

      function populateApiKey(savedKey) {
        if (savedKey) {
          console.log("Found saved API key, populating input.");
          document.getElementById('apiKey').value = savedKey;
        } else {
          console.log("No saved API key found.");
        }
      }

      function analyzeDocument() {
        const apiKey = document.getElementById('apiKey').value;
        const customPromptTemplate = document.getElementById('customPrompt').value;
        const resultsDiv = document.getElementById('results');
        const analyzeButton = document.getElementById('analyzeButton');

        if (!apiKey) {
          resultsDiv.innerHTML = '<p style="color: red;">Please enter your Gemini API Key. <a href="https://ai.google.dev/gemini-api/docs/api-key" target="_blank">Need help?</a></p>';
          return;
        }
        if (!customPromptTemplate) {
          resultsDiv.innerHTML = '<p style="color: red;">Please enter a prompt.</p>';
          return;
        }

        // Disable button and show loading state
        analyzeButton.disabled = true;
        resultsDiv.innerHTML = '<p>Fetching document content...</p>';
        stopPolling(); // Stop polling while fetching new comments

        // Save the key when analysis is attempted (if valid)
        if (apiKey) {
           console.log("Attempting to save API Key..."); // Add log for saving
           google.script.run.saveApiKey(apiKey);
        }

        google.script.run
          .withSuccessHandler(handleDocContent)
          .withFailureHandler(handleError)
          .getDocumentContent();
      }

      function handleDocContent(docContent) {
        console.log("Document Content Received (first 100 chars):", docContent.substring(0, 100));
        const apiKey = document.getElementById('apiKey').value;
        const customPromptTemplate = document.getElementById('customPrompt').value;
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = '<p>Analyzing content with Gemini...</p>';

        if (!docContent || docContent.trim().length === 0) {
            resultsDiv.innerHTML = '<p>Document is empty, nothing to analyze.</p>';
            document.getElementById('analyzeButton').disabled = false; // Re-enable button
            return;
        }

        // Replace placeholder in prompt with actual document content
        const finalPrompt = customPromptTemplate.replace(DOC_TEXT_PLACEHOLDER, docContent);

        google.script.run
          .withSuccessHandler(displayComments)
          .withFailureHandler(handleError)
          .getGeminiComments(finalPrompt, apiKey); // Pass final prompt
      }

      function displayComments(comments) {
         const resultsDiv = document.getElementById('results');
         const analyzeButton = document.getElementById('analyzeButton');
         analyzeButton.disabled = false;

         console.log("Comments received:", comments);
         currentComments = comments; // Store comments for later use
         currentlyFocusedCommentId = null; // Reset focus
         clearSidebarFocus(); // Clear visual focus

         if (!comments || comments.length === 0) {
           resultsDiv.innerHTML = '<p>No comments were generated.</p>';
           stopPolling();
           return;
         }

         // Render comments
         let html = '<h2>Generated Comments:</h2>';
         comments.forEach((comment, index) => {
           const commentId = `comment-${index}`;
           html += `<div class="comment-block" data-quote="${escapeHtml(comment.quote)}" id="${commentId}">`;
           html += `<div class="comment-quote">${escapeHtml(comment.quote)}</div>`;
           html += `<div class="comment-text">${escapeHtml(comment.comment)}</div>`;
           html += '</div>';
         });
         resultsDiv.innerHTML = html;

         // Add click listeners AFTER rendering
         comments.forEach((_, index) => {
           const commentId = `comment-${index}`;
           const element = document.getElementById(commentId);
           if (element) {
             element.addEventListener('click', () => setCommentFocus(commentId));
           }
         });

         // Initial highlighting (no focus)
         setCommentFocus(null);
      }

      function onHighlightSuccess() {
        console.log("onHighlightSuccess: Document highlighting successful. Starting polling...");
        startPolling();
      }

      function onHighlightError(error) {
        console.error("Highlighting Error:", error);
        // Maybe show a non-fatal error to the user
        // document.getElementById('results').innerHTML += '<p style="color: orange;">Could not highlight comments in document.</p>';
        // Still start polling even if highlighting fails?
        startPolling();
      }

      function handleError(error) {
        const resultsDiv = document.getElementById('results');
        const analyzeButton = document.getElementById('analyzeButton');
        analyzeButton.disabled = false; // Re-enable button
        stopPolling(); // Stop polling on error

        // Log the full error for debugging
        console.error("Script Error:", JSON.stringify(error, null, 2));

        // Display a user-friendly message
        resultsDiv.innerHTML = `<p style="color: red;">Error: ${escapeHtml(error.message || String(error))}</p>`;

        // Special handling for API key errors
        if (typeof error.message === 'string' && (error.message.includes('API key not valid') || error.message.includes('API_KEY_INVALID'))) {
            resultsDiv.innerHTML += `<p style="color: red;">Please check your Gemini API Key. <a href="https://ai.google.dev/gemini-api/docs/api-key" target="_blank">Need help?</a></p>`;
        }
      }

      // --- Cursor Focus Polling --- 

      function startPolling() {
        if (pollingInterval) {
            console.log("startPolling: Polling already active.");
            return; 
        }
        console.log("startPolling: Setting up polling interval...");
        pollingInterval = setInterval(() => {
          console.log("Polling Interval: Calling getCursorState...");
          google.script.run
            .withSuccessHandler(updateFocus)
            .withFailureHandler(logPollingError)
            .getCursorState();
        }, 1500);
      }

      function stopPolling() {
        if (pollingInterval) {
          console.log("Stopping focus polling.");
          clearInterval(pollingInterval);
          pollingInterval = null;
          clearSidebarFocus(); // Clear focus when stopping polling
          // When polling stops, ensure focus is cleared in doc too
          if (currentlyFocusedCommentId) {
            setCommentFocus(null); 
          }
        }
      }

      function updateFocus(cursorState) {
        console.log("Polling Interval: Received state:", cursorState);

        let foundCommentId = null;

        if (cursorState && cursorState.elementText && currentComments.length > 0) {
            const elementText = cursorState.elementText;
            const cursorOffset = cursorState.offset;

            for (let i = 0; i < currentComments.length; i++) {
                const comment = currentComments[i];
                const quote = comment.quote;
                let startIndex = -1;
                let searchFrom = 0;

                while ((startIndex = elementText.indexOf(quote, searchFrom)) !== -1) {
                    const endIndex = startIndex + quote.length;
                    
                    if (cursorOffset >= startIndex && cursorOffset <= endIndex) {
                        console.log(`Polling: Cursor offset ${cursorOffset} is within quote bounds [${startIndex}, ${endIndex}]. Match found for comment-${i}!`);
                        foundCommentId = `comment-${i}`;
                        break;
                    }
                    searchFrom = startIndex + 1; 
                }
                if (foundCommentId) {
                    break;
                }
            }
            if (!foundCommentId) {
                 console.log("Polling: Cursor position doesn't match any known quote bounds within the current text element.");
            }
        } else {
            console.log("Polling: No cursor state, element text, or comments available for matching.");
        }

        // Update focus based on whether a comment was found
        if (currentlyFocusedCommentId !== foundCommentId) {
             setCommentFocus(foundCommentId); // Call the central focus function
        }
      }

      /**
       * Central function to set the focus on a specific comment (or clear focus).
       * Handles both sidebar UI and document highlighting.
       * @param {string | null} commentId The ID of the comment to focus, or null to clear focus.
       */
      function setCommentFocus(commentId) {
        console.log(`Setting focus. Target comment ID: ${commentId}`);
        const previouslyFocusedId = currentlyFocusedCommentId;

        // 1. Update Sidebar UI Focus
        clearSidebarFocus(); // Clear previous sidebar visual focus
        let quoteToFocus = null;
        if (commentId) {
            const newElement = document.getElementById(commentId);
            if (newElement) {
                console.log("Focusing sidebar element:", commentId);
                newElement.classList.add('focused-comment');
                newElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                currentlyFocusedCommentId = commentId;
                // Retrieve the quote text associated with this comment ID for highlighting
                quoteToFocus = newElement.getAttribute('data-quote');
            } else {
                console.warn("setCommentFocus: Could not find comment block with id:", commentId);
                currentlyFocusedCommentId = null;
            }
        }

        // 2. Update Document Highlighting (only if focus changed or needs clearing)
        // Avoid redundant calls if the focus target is the same or already null
        if (currentlyFocusedCommentId !== previouslyFocusedId || !commentId) {
             console.log(`Requesting document highlight update. Focused quote: "${quoteToFocus || 'None'}"`);
            const allQuotes = currentComments.map(c => c.quote);
            google.script.run
                .withFailureHandler(onHighlightError) // Reuse error handler
                .highlightCommentsInDoc(allQuotes, quoteToFocus); // Pass the specific quote to focus
        }
      }

      // Renamed from clearFocus for clarity
      function clearSidebarFocus() {
         if (currentlyFocusedCommentId) {
             console.log("Clearing sidebar focus from:", currentlyFocusedCommentId);
             const oldElement = document.getElementById(currentlyFocusedCommentId);
             if (oldElement) {
                oldElement.classList.remove('focused-comment');
             }
             currentlyFocusedCommentId = null;
         }
      }

      function logPollingError(error) {
          console.warn("Polling Error (likely transient):", error);
      }

      // --- Utility Functions --- 

      // Utility function to prevent basic XSS
      function escapeHtml(unsafe) {
          if (typeof unsafe !== 'string') {
              console.warn('escapeHtml called with non-string:', unsafe);
              return unsafe; // Return as-is if not a string
          }
          return unsafe
               .replace(/&/g, "&amp;")
               .replace(/</g, "&lt;")
               .replace(/>/g, "&gt;")
               .replace(/"/g, "&quot;")
               .replace(/'/g, "&#039;");
      }

      // Utility function to escape quotes for CSS selectors
      function escapeCssSelector(str) {
        if (!str) return '';
        return str.replace(/(["'\!#$%&()*+,./:;<=>?@[\]^`{|}~])/g, '\$1');
      }

    </script>
  </body>
</html>