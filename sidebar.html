<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <style>
      /* Basic styling */
      body { font-family: sans-serif; margin: 10px; }
      #results { margin-top: 15px; border-top: 1px solid #ccc; padding-top: 10px; }
      .comment-block { border: 1px solid #eee; padding: 8px; margin-bottom: 8px; transition: border-color 0.3s ease; }
      .comment-quote { font-style: italic; color: #555; margin-bottom: 4px; }
      .comment-text { }
      button { margin-top: 5px; }
      textarea { width: 95%; margin-top: 2px; height: 80px; font-family: inherit; }
      .focused-comment { border-color: #4285F4; border-width: 2px; }
      label { display: block; margin-top: 10px; font-weight: bold;}
    </style>
  </head>
  <body>
    <h1>Document Analysis</h1>

    <div>
      <label for="apiKey">Gemini API Key:</label>
      <input type="password" id="apiKey" style="width: 95%;">
      <small>Need a key? <a href="https://ai.google.dev/gemini-api/docs/api-key" target="_blank">Get one here</a>.</small>
    </div>

    <div>
        <label for="customPrompt">Analysis Prompt:</label>
        <textarea id="customPrompt"></textarea>
    </div>

    <button id="analyzeButton">Analyze for Comments</button>

    <div id="results">
      <!-- Comments will be displayed here -->
      <p>Enter your API key and click the button to analyze.</p>
    </div>

    <script>
      const DOC_TEXT_PLACEHOLDER = '{docText}';
      const defaultPrompt = `Please review the following document text and provide constructive comments. For each comment, identify the exact phrase or sentence from the text that the comment refers to. Present your output STRICTLY as a JSON array of objects, where each object has a "quote" key (containing the exact text phrase) and a "comment" key (containing your feedback). Do not include any text outside of the JSON array.\n\nExample format:\n[\n  {\n    "quote": "This is a sentence to comment on.",\n    "comment": "This sentence could be clearer."
  },\n  {\n    "quote": "Another phrase needing feedback.",\n    "comment": "Consider rephrasing this part."
  }\n]\n\nDocument Text:\n---\n${DOC_TEXT_PLACEHOLDER}\n---`;

      document.getElementById('customPrompt').value = defaultPrompt;
      document.getElementById('analyzeButton').addEventListener('click', analyzeDocument);

      let currentComments = []; // Store the current comments with quotes
      let currentlyFocusedCommentId = null;
      let pollingInterval = null;

      function analyzeDocument() {
        const apiKey = document.getElementById('apiKey').value;
        const customPromptTemplate = document.getElementById('customPrompt').value;
        const resultsDiv = document.getElementById('results');
        const analyzeButton = document.getElementById('analyzeButton');

        if (!apiKey) {
          resultsDiv.innerHTML = '<p style="color: red;">Please enter your Gemini API Key. <a href="https://ai.google.dev/gemini-api/docs/api-key" target="_blank">Need help?</a></p>';
          return;
        }
        if (!customPromptTemplate) {
          resultsDiv.innerHTML = '<p style="color: red;">Please enter a prompt.</p>';
          return;
        }

        // Disable button and show loading state
        analyzeButton.disabled = true;
        resultsDiv.innerHTML = '<p>Fetching document content...</p>';
        stopPolling(); // Stop polling while fetching new comments

        google.script.run
          .withSuccessHandler(handleDocContent)
          .withFailureHandler(handleError)
          .getDocumentContent();
      }

      function handleDocContent(docContent) {
        console.log("Document Content Received (first 100 chars):", docContent.substring(0, 100));
        const apiKey = document.getElementById('apiKey').value;
        const customPromptTemplate = document.getElementById('customPrompt').value;
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = '<p>Analyzing content with Gemini...</p>';

        if (!docContent || docContent.trim().length === 0) {
            resultsDiv.innerHTML = '<p>Document is empty, nothing to analyze.</p>';
            document.getElementById('analyzeButton').disabled = false; // Re-enable button
            return;
        }

        // Replace placeholder in prompt with actual document content
        const finalPrompt = customPromptTemplate.replace(DOC_TEXT_PLACEHOLDER, docContent);

        google.script.run
          .withSuccessHandler(displayComments)
          .withFailureHandler(handleError)
          .getGeminiComments(finalPrompt, apiKey); // Pass final prompt
      }

      function displayComments(comments) {
         const resultsDiv = document.getElementById('results');
         const analyzeButton = document.getElementById('analyzeButton');
         analyzeButton.disabled = false;

         console.log("Comments received:", comments);
         currentComments = comments; // Store comments for later use
         currentlyFocusedCommentId = null; // Reset focus
         clearFocus(); // Clear visual focus

         if (!comments || comments.length === 0) {
           resultsDiv.innerHTML = '<p>No comments were generated.</p>';
           stopPolling();
           return;
         }

         // Render comments
         let html = '<h2>Generated Comments:</h2>';
         comments.forEach((comment, index) => {
           const commentId = `comment-${index}`;
           // Use commentId for the div id
           html += `<div class="comment-block" data-quote="${escapeHtml(comment.quote)}" id="${commentId}">`;
           html += `<div class="comment-quote">${escapeHtml(comment.quote)}</div>`;
           html += `<div class="comment-text">${escapeHtml(comment.comment)}</div>`;
           html += '</div>';
         });
         resultsDiv.innerHTML = html;

         // After rendering, extract quotes and request highlighting
         const quotesToHighlight = comments.map(c => c.quote);
         console.log("Requesting document highlighting for quotes:", quotesToHighlight);
         google.script.run
            .withSuccessHandler(onHighlightSuccess)
            .withFailureHandler(onHighlightError)
            .highlightCommentsInDoc(quotesToHighlight); // Pass only quotes
      }

      function onHighlightSuccess() {
        console.log("Document highlighting successful.");
        // Start polling for cursor focus
        startPolling();
      }

      function onHighlightError(error) {
        console.error("Highlighting Error:", error);
        // Maybe show a non-fatal error to the user
        // document.getElementById('results').innerHTML += '<p style="color: orange;">Could not highlight comments in document.</p>';
        // Still start polling even if highlighting fails?
        startPolling();
      }

      function handleError(error) {
        const resultsDiv = document.getElementById('results');
        const analyzeButton = document.getElementById('analyzeButton');
        analyzeButton.disabled = false; // Re-enable button
        stopPolling(); // Stop polling on error

        // Log the full error for debugging
        console.error("Script Error:", JSON.stringify(error, null, 2));

        // Display a user-friendly message
        resultsDiv.innerHTML = `<p style="color: red;">Error: ${escapeHtml(error.message || String(error))}</p>`;

        // Special handling for API key errors
        if (typeof error.message === 'string' && (error.message.includes('API key not valid') || error.message.includes('API_KEY_INVALID'))) {
            resultsDiv.innerHTML += `<p style="color: red;">Please check your Gemini API Key. <a href="https://ai.google.dev/gemini-api/docs/api-key" target="_blank">Need help?</a></p>`;
        }
      }

      // --- Cursor Focus Polling --- 

      function startPolling() {
        if (pollingInterval) return;
        console.log("Starting focus polling interval.");
        pollingInterval = setInterval(() => {
          console.log("Polling: Calling getCursorState..."); // Updated function name
          google.script.run
            .withSuccessHandler(updateFocus)
            .withFailureHandler(logPollingError)
            .getCursorState(); // Updated function name
        }, 1500);
      }

      function stopPolling() {
        if (pollingInterval) {
          console.log("Stopping focus polling.");
          clearInterval(pollingInterval);
          pollingInterval = null;
          clearFocus(); // Clear focus when stopping polling
        }
      }

      function updateFocus(cursorState) {
        console.log("Polling: Received from getCursorState:", cursorState);

        if (!cursorState || cursorState.bgColor !== HIGHLIGHT_COLOR) {
            // Cursor is not in a highlighted area, clear focus
            if (currentlyFocusedCommentId !== null) {
                console.log("Polling: Cursor left highlighted area, clearing focus.");
                clearFocus();
            }
            return;
        }

        // Cursor IS in a highlighted area. Find which comment corresponds.
        // Since we don't get the exact quote back anymore, we assume the *first* comment block
        // rendered in the sidebar corresponds to the highlighted area. This is a simplification
        // and might be incorrect if quotes overlap or are identical.
        // A more robust solution would require Code.gs to return more context (e.g., paragraph text
        // and offset) and the sidebar to match against its known comment locations.
        if (currentComments.length > 0) {
            // For now, just focus the first comment as a placeholder for being in *any* highlight
            const firstCommentId = 'comment-0'; 
            if (currentlyFocusedCommentId !== firstCommentId) {
                console.log(`Polling: Cursor in highlighted area. Focusing first comment (id: ${firstCommentId}) as placeholder.`);
                setFocus(firstCommentId);
            }
        } else {
             // Highlight detected but no comments stored? Clear focus.
             if (currentlyFocusedCommentId !== null) {
                console.log("Polling: Cursor in highlight, but no comments known. Clearing focus.");
                clearFocus();
            }
        }
      }

      function setFocus(commentId) {
        clearFocus(); // Clear previous focus first
        const newElement = document.getElementById(commentId);
        if (newElement) {
            console.log("Focusing comment:", commentId);
            newElement.classList.add('focused-comment');
            // Optional: Scroll into view
            newElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            currentlyFocusedCommentId = commentId;
        } else {
            console.warn("setFocus: Could not find comment block with id:", commentId);
            currentlyFocusedCommentId = null;
        }
      }

      function clearFocus() {
         if (currentlyFocusedCommentId) {
             console.log("Clearing focus from:", currentlyFocusedCommentId);
             const oldElement = document.getElementById(currentlyFocusedCommentId);
             if (oldElement) {
                oldElement.classList.remove('focused-comment');
             }
             currentlyFocusedCommentId = null;
         }
      }

      function logPollingError(error) {
          console.warn("Polling Error (likely transient):", error);
      }

      // --- Utility Functions --- 

      // Utility function to prevent basic XSS
      function escapeHtml(unsafe) {
          if (typeof unsafe !== 'string') {
              console.warn('escapeHtml called with non-string:', unsafe);
              return unsafe; // Return as-is if not a string
          }
          return unsafe
               .replace(/&/g, "&amp;")
               .replace(/</g, "&lt;")
               .replace(/>/g, "&gt;")
               .replace(/"/g, "&quot;")
               .replace(/'/g, "&#039;");
      }

      // Utility function to escape quotes for CSS selectors
      function escapeCssSelector(str) {
        if (!str) return '';
        return str.replace(/(["'\\!#$%&()*+,./:;<=>?@[\]^`{|}~])/g, '\\$1');
      }

    </script>
  </body>
</html> 